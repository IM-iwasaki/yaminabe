// Upgrade NOTE: replaced 'defined FOG_COMBINED_WITH_WORLD_POS' with 'defined (FOG_COMBINED_WITH_WORLD_POS)'

// Made with Amplify Shader Editor
// Available at the Unity Asset Store - http://u3d.as/y3X 
Shader "S_Crown"
{
	Properties
	{
		_Animation("-----Animation-----", Float) = 1
		[Toggle(_SWITCHROTATE_ON)] _SwitchRotate("SwitchRotate", Float) = 0
		_UpDownSpeed("UpDownSpeed", Range( 0 , 2)) = 1
		_UpDownValue("UpDownValue", Range( 0 , 2)) = 1
		_RatateSpeed("RatateSpeed", Range( 0 , 2)) = 1
		_RandomTiltSpeed("RandomTiltSpeed", Range( 0 , 2)) = 1
		_RandomTiltValue("RandomTiltValue", Range( 0 , 2)) = 1
		_Base("-----Base-----", Float) = 1
		_Color0("Color 0", Color) = (0.3294118,0.2862745,0.2431373,1)
		_Color1("Color 1", Color) = (0.9529412,0.9490197,0.8666667,1)
		_Light("-----Light------", Float) = 1
		_LightWeight("LightWeight", Range( 0 , 1)) = 0.5
		[Toggle(_USE_CUSTOMLIGHTCOLOR_ON)] _Use_CustomLightColor("Use_CustomLightColor", Float) = 0
		_CustomLightColor("CustomLightColor", Color) = (1,1,1,0)
		_ShadowIntensity("ShadowIntensity", Range( 0 , 1)) = 0.5
		_Shadow_Color("Shadow_Color", Color) = (0.482353,0.4392157,0.4117647,1)
		_AnimeHighlightColor("AnimeHighlightColor ", Color) = (0.482353,0.4392157,0.4117647,1)
		_RimLightColor("RimLightColor", Color) = (0.5188679,0.5188679,0.5188679,0)
		_HairReflectionColor("HairReflectionColor", Color) = (0.1921568,0.6039216,0.5618846,0)
		_Opacity("-----Opacity-----", Float) = 1
		[Toggle(_USE_OPACITYMASK_ON)] _Use_OpacityMask("Use_OpacityMask", Float) = 0
		[Toggle(_USE_PATTERNOUTLINE_ON)] _Use_PatternOutline("Use_PatternOutline", Float) = 0
		_PatternOutlineColor("PatternOutlineColor", Color) = (0,0,0,0)
		_Tx_Opacity("Tx_Opacity", 2D) = "white" {}
		_Resouce("-----Resouce-----", Float) = 1
		_Cutoff( "Mask Clip Value", Float ) = 0.5
		_TextureNormal("TextureNormal", 2D) = "bump" {}
		_CrownTex_hairref("CrownTex_hairref", 2D) = "white" {}
		_Tx_highlight("Tx_highlight", 2D) = "white" {}
		_Tx_4s8f("Tx_4s8f", 2D) = "white" {}
		_Tx_CrownMatCap_01("Tx_CrownMatCap_01", 2D) = "white" {}
		[HideInInspector] _texcoord2( "", 2D ) = "white" {}
		[HideInInspector] _texcoord( "", 2D ) = "white" {}
		[HideInInspector] __dirty( "", Int ) = 1
	}

	SubShader
	{
		Tags{ "RenderType" = "Opaque"  "Queue" = "AlphaTest+0" "IgnoreProjector" = "True" }
		Cull Off
		#LINE 411

		
	// ------------------------------------------------------------
	// Surface shader code generated out of a CGPROGRAM block:
	

	// ---- forward rendering base pass:
	Pass {
		Name "FORWARD"
		Tags { "LightMode" = "ForwardBase" }

CGPROGRAM
// compile directives
#pragma vertex vert_surf
#pragma fragment frag_surf
#pragma target 4.6
#pragma shader_feature_local _SWITCHROTATE_ON
#pragma shader_feature_local _USE_OPACITYMASK_ON
#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
#pragma multi_compile_instancing
#pragma multi_compile_fog
#pragma multi_compile_fwdbase
#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
// -------- variant for: <when no other keywords are defined>
#if !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_PATTERNOUTLINE_ON 
#if defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON 
#if defined(_USE_OPACITYMASK_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON 
#if defined(_SWITCHROTATE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON 
#if defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_LIGHTING_COORDS(5,6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD4; // SH
  #endif
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD7;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  float4 lmap : TEXCOORD4;
  UNITY_FOG_COORDS(5)
  UNITY_SHADOW_COORDS(6)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
      o.sh = 0;
      // Approximated illumination from non-important point lights
      #ifdef VERTEXLIGHT_ON
        o.sh += Shade4PointLights (
          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
          unity_4LightAtten0, worldPos, worldNormal);
      #endif
      o.sh = ShadeSHPerVertex (worldNormal, o.sh);
    #endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
    UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
    giInput.lightmapUV = IN.lmap;
  #else
    giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
    giInput.ambient = IN.sh;
  #else
    giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
    giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
    giInput.boxMax[0] = unity_SpecCube0_BoxMax;
    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
    giInput.boxMax[1] = unity_SpecCube1_BoxMax;
    giInput.boxMin[1] = unity_SpecCube1_BoxMin;
    giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustomLighting_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif


ENDCG

}

	// ---- forward rendering additive lights pass:
	Pass {
		Name "FORWARD"
		Tags { "LightMode" = "ForwardAdd" }
		ZWrite Off Blend One One

CGPROGRAM
// compile directives
#pragma vertex vert_surf
#pragma fragment frag_surf
#pragma target 4.6
#pragma shader_feature_local _SWITCHROTATE_ON
#pragma shader_feature_local _USE_OPACITYMASK_ON
#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
#pragma multi_compile_instancing
#pragma multi_compile_fog
#pragma skip_variants INSTANCING_ON
#pragma multi_compile_fwdadd_fullshadows
#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
// -------- variant for: <when no other keywords are defined>
#if !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_PATTERNOUTLINE_ON 
#if defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON 
#if defined(_USE_OPACITYMASK_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON 
#if defined(_SWITCHROTATE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv2_texcoord2 = IN.pack0.xy;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: YES
// needs screen space position: no
// needs world space position: YES
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord2
#include "UnityCG.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord2
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  UNITY_LIGHTING_COORDS(5,6)
  UNITY_FOG_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord2_ST;

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord1, _texcoord2);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv2_texcoord2 = IN.pack0.zw;
  float3 worldPos = IN.worldPos.xyz;
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.worldNormal = 0.0;
  surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
  surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
  surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
  surfIN.worldPos = worldPos;
  #if UNITY_VFACE_FLIPPED
     vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  gi.light.color *= atten;
  c += LightingStandardCustomLighting (o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif


ENDCG

}

	// ---- meta information extraction pass:
	Pass {
		Name "Meta"
		Tags { "LightMode" = "Meta" }
		Cull Off

CGPROGRAM
// compile directives
#pragma vertex vert_surf
#pragma fragment frag_surf
#pragma target 4.6
#pragma shader_feature_local _SWITCHROTATE_ON
#pragma shader_feature_local _USE_OPACITYMASK_ON
#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
#pragma multi_compile_instancing
#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
#pragma shader_feature EDITOR_VISUALIZATION

#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
// -------- variant for: <when no other keywords are defined>
#if !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_PATTERNOUTLINE_ON 
#if defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON 
#if defined(_USE_OPACITYMASK_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON 
#if defined(_SWITCHROTATE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(INSTANCING_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON 
#if defined(INSTANCING_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_SWITCHROTATE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_OPACITYMASK_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON) && !defined(_USE_PATTERNOUTLINE_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && !defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON _SWITCHROTATE_ON _USE_OPACITYMASK_ON _USE_PATTERNOUTLINE_ON _USE_CUSTOMLIGHTCOLOR_ON 
#if defined(INSTANCING_ON) && defined(_SWITCHROTATE_ON) && defined(_USE_OPACITYMASK_ON) && defined(_USE_PATTERNOUTLINE_ON) && defined(_USE_CUSTOMLIGHTCOLOR_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 0 texcoords actually used
#include "UnityCG.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		//#pragma target 4.6
		//#pragma shader_feature_local _SWITCHROTATE_ON
		//#pragma shader_feature_local _USE_OPACITYMASK_ON
		//#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		//#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 410 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		//#pragma surface surf StandardCustomLighting keepalpha fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 

		
#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 tSpace0 : TEXCOORD0;
  float4 tSpace1 : TEXCOORD1;
  float4 tSpace2 : TEXCOORD2;
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD3;
  float4 lightCoord : TEXCOORD4;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};

// vertex shader
v2f_surf vert_surf (appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc (v, customInputData);
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
    o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
    o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  return o;
}

// fragment shader
fixed4 frag_surf (v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
    UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
    UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
    UNITY_RECONSTRUCT_TBN(IN);
  #else
    UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.worldNormal.x = 1.0;
  surfIN.worldPos.x = 1.0;
  surfIN.uv2_texcoord2.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
    fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputCustomLightingCustom o = (SurfaceOutputCustomLightingCustom)0;
  #else
  SurfaceOutputCustomLightingCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);

  // call surface function
  surf (surfIN, o);
  UnityMetaInput metaIN;
  UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
  metaIN.Albedo = o.Albedo;
  metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif


ENDCG

}

	// ---- end of surface shader generated code

#LINE 415

		Pass
		{
			Name "ShadowCaster"
			Tags{ "LightMode" = "ShadowCaster" }
			ZWrite On
			CGPROGRAM
#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
#line 48

		#include "UnityPBSLighting.cginc"
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		#pragma target 4.6
		#pragma shader_feature_local _SWITCHROTATE_ON
		#pragma shader_feature_local _USE_OPACITYMASK_ON
		#pragma shader_feature_local _USE_PATTERNOUTLINE_ON
		#pragma shader_feature_local _USE_CUSTOMLIGHTCOLOR_ON
		#ifdef UNITY_PASS_SHADOWCASTER
			#undef INTERNAL_DATA
			#undef WorldReflectionVector
			#undef WorldNormalVector
			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))
		#endif
		struct Input
		{
			float2 uv_texcoord;
			float3 worldNormal;
			INTERNAL_DATA
			float3 worldPos;
			float2 uv2_texcoord2;
			half ASEVFace : VFACE;
		};

		struct SurfaceOutputCustomLightingCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			Input SurfInput;
			UnityGIInput GIData;
		};

		uniform float _RandomTiltSpeed;
		uniform float _RandomTiltValue;
		uniform float _RatateSpeed;
		uniform float _UpDownSpeed;
		uniform float _UpDownValue;
		uniform sampler2D _Tx_Opacity;
		uniform float4 _Tx_Opacity_ST;
		uniform float4 _HairReflectionColor;
		uniform float4 _RimLightColor;
		uniform float4 _AnimeHighlightColor;
		uniform float4 _CustomLightColor;
		uniform float4 _Color0;
		uniform float4 _Color1;
		uniform sampler2D _Tx_CrownMatCap_01;
		uniform sampler2D _TextureNormal;
		uniform float4 _TextureNormal_ST;
		uniform float _LightWeight;
		uniform float4 _Shadow_Color;
		uniform float _ShadowIntensity;
		uniform sampler2D _Tx_highlight;
		uniform sampler2D _Tx_4s8f;
		uniform sampler2D _CrownTex_hairref;
		uniform float4 _CrownTex_hairref_ST;
		uniform float _Light;
		uniform float _Base;
		uniform float _Resouce;
		uniform float _Animation;
		uniform float _Opacity;
		uniform float4 _PatternOutlineColor;
		uniform float _Cutoff = 0.5;


		float3 RotateAroundAxis( float3 center, float3 original, float3 u, float angle )
		{
			original -= center;
			float C = cos( angle );
			float S = sin( angle );
			float t = 1 - C;
			float m00 = t * u.x * u.x + C;
			float m01 = t * u.x * u.y - S * u.z;
			float m02 = t * u.x * u.z + S * u.y;
			float m10 = t * u.x * u.y + S * u.z;
			float m11 = t * u.y * u.y + C;
			float m12 = t * u.y * u.z - S * u.x;
			float m20 = t * u.x * u.z - S * u.y;
			float m21 = t * u.y * u.z + S * u.x;
			float m22 = t * u.z * u.z + C;
			float3x3 finalMatrix = float3x3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );
			return mul( finalMatrix, original ) + center;
		}


		struct Gradient
		{
			int type;
			int colorsLength;
			int alphasLength;
			float4 colors[8];
			float2 alphas[8];
		};


		Gradient NewGradient(int type, int colorsLength, int alphasLength, 
		float4 colors0, float4 colors1, float4 colors2, float4 colors3, float4 colors4, float4 colors5, float4 colors6, float4 colors7,
		float2 alphas0, float2 alphas1, float2 alphas2, float2 alphas3, float2 alphas4, float2 alphas5, float2 alphas6, float2 alphas7)
		{
			Gradient g;
			g.type = type;
			g.colorsLength = colorsLength;
			g.alphasLength = alphasLength;
			g.colors[ 0 ] = colors0;
			g.colors[ 1 ] = colors1;
			g.colors[ 2 ] = colors2;
			g.colors[ 3 ] = colors3;
			g.colors[ 4 ] = colors4;
			g.colors[ 5 ] = colors5;
			g.colors[ 6 ] = colors6;
			g.colors[ 7 ] = colors7;
			g.alphas[ 0 ] = alphas0;
			g.alphas[ 1 ] = alphas1;
			g.alphas[ 2 ] = alphas2;
			g.alphas[ 3 ] = alphas3;
			g.alphas[ 4 ] = alphas4;
			g.alphas[ 5 ] = alphas5;
			g.alphas[ 6 ] = alphas6;
			g.alphas[ 7 ] = alphas7;
			return g;
		}


		float4 SampleGradient( Gradient gradient, float time )
		{
			float3 color = gradient.colors[0].rgb;
			UNITY_UNROLL
			for (int c = 1; c < 8; c++)
			{
			float colorPos = saturate((time - gradient.colors[c-1].w) / ( 0.00001 + (gradient.colors[c].w - gradient.colors[c-1].w)) * step(c, (float)gradient.colorsLength-1));
			color = lerp(color, gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), gradient.type));
			}
			#ifndef UNITY_COLORSPACE_GAMMA
			color = half3(GammaToLinearSpaceExact(color.r), GammaToLinearSpaceExact(color.g), GammaToLinearSpaceExact(color.b));
			#endif
			float alpha = gradient.alphas[0].x;
			UNITY_UNROLL
			for (int a = 1; a < 8; a++)
			{
			float alphaPos = saturate((time - gradient.alphas[a-1].y) / ( 0.00001 + (gradient.alphas[a].y - gradient.alphas[a-1].y)) * step(a, (float)gradient.alphasLength-1));
			alpha = lerp(alpha, gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), gradient.type));
			}
			return float4(color, alpha);
		}


		void vertexDataFunc( inout appdata_full v, out Input o )
		{
			UNITY_INITIALIZE_OUTPUT( Input, o );
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertex3Pos = v.vertex.xyz;
			float3 rotatedValue244 = RotateAroundAxis( float3( 0,0,0 ), ase_vertex3Pos, normalize( appendResult502 ), mulTime246 );
			float mulTime495 = _Time.y * _UpDownSpeed;
			float3 appendResult370 = (float3(0.0 , ( sin( mulTime495 ) * ( _UpDownValue * 5E-05 ) ) , 0.0));
			float3 VertexPosition401 = ( rotatedValue244 + appendResult370 );
			v.vertex.xyz = VertexPosition401;
			v.vertex.w = 1;
			float3 ase_vertexNormal = v.normal.xyz;
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			v.normal = VertexNormal487;
		}

		inline half4 LightingStandardCustomLighting( inout SurfaceOutputCustomLightingCustom s, half3 viewDir, UnityGI gi )
		{
			UnityGIInput data = s.GIData;
			Input i = s.SurfInput;
			half4 c = 0;
			#ifdef UNITY_PASS_FORWARDBASE
			float ase_lightAtten = data.atten;
			if( _LightColor0.a == 0)
			ase_lightAtten = 0;
			#else
			float3 ase_lightAttenRGB = gi.light.color / ( ( _LightColor0.rgb ) + 0.000001 );
			float ase_lightAtten = max( max( ase_lightAttenRGB.r, ase_lightAttenRGB.g ), ase_lightAttenRGB.b );
			#endif
			#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
			half bakedAtten = UnitySampleBakedOcclusion(data.lightmapUV.xy, data.worldPos);
			float zDist = dot(_WorldSpaceCameraPos - data.worldPos, UNITY_MATRIX_V[2].xyz);
			float fadeDist = UnityComputeShadowFadeDistance(data.worldPos, zDist);
			ase_lightAtten = UnityMixRealtimeAndBakedShadows(data.atten, bakedAtten, UnityComputeShadowFade(fadeDist));
			#endif
			float2 uv_Tx_Opacity = i.uv_texcoord * _Tx_Opacity_ST.xy + _Tx_Opacity_ST.zw;
			float4 tex2DNode646 = tex2D( _Tx_Opacity, uv_Tx_Opacity );
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch654 = max( tex2DNode646.r , tex2DNode646.b );
			#else
				float staticSwitch654 = tex2DNode646.r;
			#endif
			float Opacity633 = staticSwitch654;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch558 = Opacity633;
			#else
				float staticSwitch558 = 1.0;
			#endif
			#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
			float4 ase_lightColor = 0;
			#else //aselc
			float4 ase_lightColor = _LightColor0;
			#endif //aselc
			#ifdef _USE_CUSTOMLIGHTCOLOR_ON
				float4 staticSwitch390 = _CustomLightColor;
			#else
				float4 staticSwitch390 = ase_lightColor;
			#endif
			float2 temp_cast_0 = (0.5).xx;
			float2 temp_output_1_0_g95 = temp_cast_0;
			float4 color666 = IsGammaSpace() ? float4(0,0,1,0) : float4(0,0,1,0);
			float2 uv_TextureNormal = i.uv_texcoord * _TextureNormal_ST.xy + _TextureNormal_ST.zw;
			float3 tex2DNode557 = UnpackNormal( tex2D( _TextureNormal, uv_TextureNormal ) );
			float2 appendResult639 = (float2(tex2DNode557.r , tex2DNode557.g));
			#ifdef _USE_PATTERNOUTLINE_ON
				float staticSwitch655 = tex2DNode646.b;
			#else
				float staticSwitch655 = 0.0;
			#endif
			float OutlineMask636 = staticSwitch655;
			float3 appendResult642 = (float3(( appendResult639 * ( 1.0 - OutlineMask636 ) ) , tex2DNode557.b));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch561 = float4( appendResult642 , 0.0 );
			#else
				float4 staticSwitch561 = color666;
			#endif
			float2 A19_g95 = ( ( temp_output_1_0_g95 * -1.0 ) + ( 0.5 + ( 0.5 * (mul( UNITY_MATRIX_V, float4( (WorldNormalVector( i , staticSwitch561.rgb )) , 0.0 ) ).xyz).xy ) ) );
			float temp_output_3_0_g95 = 0.0;
			float temp_output_15_0_g95 = cos( temp_output_3_0_g95 );
			float temp_output_12_0_g95 = sin( temp_output_3_0_g95 );
			float2 appendResult18_g95 = (float2(temp_output_15_0_g95 , ( temp_output_12_0_g95 * -1.0 )));
			float dotResult11_g95 = dot( A19_g95 , appendResult18_g95 );
			float2 appendResult17_g95 = (float2(temp_output_12_0_g95 , temp_output_15_0_g95));
			float dotResult16_g95 = dot( A19_g95 , appendResult17_g95 );
			float2 appendResult22_g95 = (float2(dotResult11_g95 , dotResult16_g95));
			float Base315 = saturate( tex2D( _Tx_CrownMatCap_01, ( temp_output_1_0_g95 + appendResult22_g95 ) ).r );
			float4 lerpResult263 = lerp( _Color0 , _Color1 , Base315);
			float4 blendOpSrc308 = staticSwitch390;
			float4 blendOpDest308 = lerpResult263;
			float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
			float3 ase_normWorldNormal = normalize( ase_worldNormal );
			float3 ase_worldPos = i.worldPos;
			#if defined(LIGHTMAP_ON) && UNITY_VERSION < 560 //aseld
			float3 ase_worldlightDir = 0;
			#else //aseld
			float3 ase_worldlightDir = Unity_SafeNormalize( UnityWorldSpaceLightDir( ase_worldPos ) );
			#endif //aseld
			float dotResult195 = dot( ase_normWorldNormal , ase_worldlightDir );
			float temp_output_197_0 = min( saturate( dotResult195 ) , ase_lightAtten );
			float temp_output_2_0_g103 = 0.58;
			float clampResult7_g103 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g103 ) / ( 0.58 - temp_output_2_0_g103 ) ) , 0.0 , 1.0 );
			float temp_output_2_0_g94 = 0.4;
			float clampResult7_g94 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g94 ) / ( 0.4 - temp_output_2_0_g94 ) ) , 0.0 , 1.0 );
			float HightLightMask301 = saturate( ( ( ( 3.0 - ( 2.0 * clampResult7_g103 ) ) * ( clampResult7_g103 * clampResult7_g103 ) ) + ( ( ( 3.0 - ( 2.0 * clampResult7_g94 ) ) * ( clampResult7_g94 * clampResult7_g94 ) ) * 0.3 ) ) );
			float4 lerpBlendMode308 = lerp(blendOpDest308,( blendOpSrc308 + blendOpDest308 ),( HightLightMask301 * _LightWeight ));
			UnityGI gi342 = gi;
			float3 diffNorm342 = ase_worldNormal;
			gi342 = UnityGI_Base( data, 1, diffNorm342 );
			float3 indirectDiffuse342 = gi342.indirect.diffuse + diffNorm342 * 0.0001;
			float temp_output_2_0_g102 = 0.0;
			float clampResult7_g102 = clamp( ( ( temp_output_197_0 - temp_output_2_0_g102 ) / ( 0.23 - temp_output_2_0_g102 ) ) , 0.0 , 1.0 );
			float ShadowMask339 = ( 1.0 - ( ( 3.0 - ( 2.0 * clampResult7_g102 ) ) * ( clampResult7_g102 * clampResult7_g102 ) ) );
			float4 lerpResult344 = lerp( ( saturate( lerpBlendMode308 )) , ( float4( indirectDiffuse342 , 0.0 ) * _Shadow_Color ) , ( ShadowMask339 * _ShadowIntensity ));
			float4 blendOpSrc311 = _AnimeHighlightColor;
			float4 blendOpDest311 = lerpResult344;
			float temp_output_4_0_g111 = 4.0;
			float temp_output_5_0_g111 = 8.0;
			float2 appendResult7_g111 = (float2(temp_output_4_0_g111 , temp_output_5_0_g111));
			float totalFrames39_g111 = ( temp_output_4_0_g111 * temp_output_5_0_g111 );
			float2 appendResult8_g111 = (float2(totalFrames39_g111 , temp_output_5_0_g111));
			float mulTime275 = _Time.y * 30.0;
			float clampResult42_g111 = clamp( 0.0 , 0.0001 , ( totalFrames39_g111 - 1.0 ) );
			float temp_output_35_0_g111 = frac( ( ( mulTime275 + clampResult42_g111 ) / totalFrames39_g111 ) );
			float2 appendResult29_g111 = (float2(temp_output_35_0_g111 , ( 1.0 - temp_output_35_0_g111 )));
			float2 temp_output_15_0_g111 = ( ( i.uv2_texcoord2 / appendResult7_g111 ) + ( floor( ( appendResult8_g111 * appendResult29_g111 ) ) / appendResult7_g111 ) );
			float temp_output_4_0_g112 = 4.0;
			float temp_output_5_0_g112 = 32.0;
			float2 appendResult7_g112 = (float2(temp_output_4_0_g112 , temp_output_5_0_g112));
			float totalFrames39_g112 = ( temp_output_4_0_g112 * temp_output_5_0_g112 );
			float2 appendResult8_g112 = (float2(totalFrames39_g112 , temp_output_5_0_g112));
			float mulTime281 = _Time.y * 30.0;
			float clampResult42_g112 = clamp( 0.0 , 0.0001 , ( totalFrames39_g112 - 1.0 ) );
			float temp_output_35_0_g112 = frac( ( ( mulTime281 + clampResult42_g112 ) / totalFrames39_g112 ) );
			float2 appendResult29_g112 = (float2(temp_output_35_0_g112 , ( 1.0 - temp_output_35_0_g112 )));
			float2 temp_output_15_0_g112 = ( ( i.uv2_texcoord2 / appendResult7_g112 ) + ( floor( ( appendResult8_g112 * appendResult29_g112 ) ) / appendResult7_g112 ) );
			float4 AnimHighlight295 = ( tex2D( _Tx_highlight, temp_output_15_0_g111 ) * tex2D( _Tx_4s8f, temp_output_15_0_g112 ) );
			float4 lerpBlendMode311 = lerp(blendOpDest311,( 1.0 - ( 1.0 - blendOpSrc311 ) * ( 1.0 - blendOpDest311 ) ),AnimHighlight295.r);
			float4 blendOpSrc426 = _RimLightColor;
			float4 blendOpDest426 = ( saturate( lerpBlendMode311 ));
			Gradient gradient533 = NewGradient( 0, 2, 2, float4( 0, 0, 0, 0 ), float4( 1, 1, 1, 1 ), 0, 0, 0, 0, 0, 0, float2( 1, 0 ), float2( 1, 1 ), 0, 0, 0, 0, 0, 0 );
			float3 ase_worldViewDir = normalize( UnityWorldSpaceViewDir( ase_worldPos ) );
			float fresnelNdotV428 = dot( ase_worldNormal, ase_worldViewDir );
			float fresnelNode428 = ( 0.0 + 1.58 * pow( 1.0 - fresnelNdotV428, 1.89 ) );
			float4 switchResult427 = (((i.ASEVFace>0)?(saturate( SampleGradient( gradient533, ( ( floor( ( fresnelNode428 * 2.0 ) ) / 2.0 ) * ShadowMask339 ) ) )):(float4( 0,0,0,0 ))));
			float4 lerpBlendMode426 = lerp(blendOpDest426,( 1.0 - ( 1.0 - blendOpSrc426 ) * ( 1.0 - blendOpDest426 ) ),switchResult427.r);
			float4 blendOpSrc581 = _HairReflectionColor;
			float4 blendOpDest581 = ( saturate( lerpBlendMode426 ));
			float mulTime513 = _Time.y * _RandomTiltSpeed;
			float temp_output_510_0 = ( _RandomTiltValue * 0.025 );
			float3 appendResult502 = (float3(( cos( mulTime513 ) * temp_output_510_0 ) , 1.0 , ( ( sin( mulTime513 ) * temp_output_510_0 ) * -1.0 )));
			#ifdef _SWITCHROTATE_ON
				float staticSwitch661 = -1.0;
			#else
				float staticSwitch661 = 1.0;
			#endif
			float mulTime246 = _Time.y * ( ( _RatateSpeed * 0.25 ) * staticSwitch661 );
			float3 ase_vertexNormal = mul( unity_WorldToObject, float4( ase_worldNormal, 0 ) );
			float3 rotatedValue483 = RotateAroundAxis( float3( 0,0,0 ), ase_vertexNormal, normalize( appendResult502 ), mulTime246 );
			float3 VertexNormal487 = rotatedValue483;
			float2 uv_CrownTex_hairref = i.uv_texcoord * _CrownTex_hairref_ST.xy + _CrownTex_hairref_ST.zw;
			#ifdef _USE_OPACITYMASK_ON
				float staticSwitch626 = tex2D( _CrownTex_hairref, uv_CrownTex_hairref ).r;
			#else
				float staticSwitch626 = (( ( VertexNormal487 * -1.0 ) * 50.0 )).y;
			#endif
			float4 lerpBlendMode581 = lerp(blendOpDest581,( 1.0 - ( 1.0 - blendOpSrc581 ) * ( 1.0 - blendOpDest581 ) ),saturate( staticSwitch626 ));
			float4 CustomLight207 = ( saturate( lerpBlendMode581 ));
			float ifLocalVar385 = 0;
			ifLocalVar385 = 1.0;
			float ifLocalVar387 = 0;
			ifLocalVar387 = 1.0;
			float ifLocalVar394 = 0;
			ifLocalVar394 = 1.0;
			float ifLocalVar489 = 0;
			ifLocalVar489 = 1.0;
			float ifLocalVar649 = 0;
			ifLocalVar649 = 1.0;
			float4 Fin383 = ( ( ( ( ( ( ( ( ( ( CustomLight207 * ifLocalVar385 ) / ifLocalVar385 ) * ifLocalVar387 ) / ifLocalVar387 ) * ifLocalVar394 ) / ifLocalVar394 ) * ifLocalVar489 ) / ifLocalVar489 ) * ifLocalVar649 ) / ifLocalVar649 );
			float4 lerpResult644 = lerp( Fin383 , _PatternOutlineColor , ( 1.0 - ( tex2DNode646.r * 1.0 ) ));
			#ifdef _USE_OPACITYMASK_ON
				float4 staticSwitch652 = lerpResult644;
			#else
				float4 staticSwitch652 = Fin383;
			#endif
			c.rgb = staticSwitch652.rgb;
			c.a = 1;
			clip( staticSwitch558 - _Cutoff );
			return c;
		}

		inline void LightingStandardCustomLighting_GI( inout SurfaceOutputCustomLightingCustom s, UnityGIInput data, inout UnityGI gi )
		{
			s.GIData = data;
		}

		void surf( Input i , inout SurfaceOutputCustomLightingCustom o )
		{
			o.SurfInput = i;
			o.Normal = float3(0,0,1);
		}

		#line 419 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
			#pragma vertex vert
			#pragma fragment frag
			#pragma target 4.6
			#pragma multi_compile_shadowcaster
			#pragma multi_compile UNITY_PASS_SHADOWCASTER
			#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
			#include "HLSLSupport.cginc"
			#if ( SHADER_API_D3D11 || SHADER_API_GLCORE || SHADER_API_GLES || SHADER_API_GLES3 || SHADER_API_METAL || SHADER_API_VULKAN )
				#define CAN_SKIP_VPOS
			#endif
			#include "UnityCG.cginc"
			#include "Lighting.cginc"
			#include "UnityPBSLighting.cginc"
			struct v2f
			{
				V2F_SHADOW_CASTER;
				float4 customPack1 : TEXCOORD1;
				float4 tSpace0 : TEXCOORD2;
				float4 tSpace1 : TEXCOORD3;
				float4 tSpace2 : TEXCOORD4;
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};
			v2f vert( appdata_full v )
			{
				v2f o;
				UNITY_SETUP_INSTANCE_ID( v );
				UNITY_INITIALIZE_OUTPUT( v2f, o );
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO( o );
				UNITY_TRANSFER_INSTANCE_ID( v, o );
				Input customInputData;
				vertexDataFunc( v, customInputData );
				float3 worldPos = mul( unity_ObjectToWorld, v.vertex ).xyz;
				half3 worldNormal = UnityObjectToWorldNormal( v.normal );
				half3 worldTangent = UnityObjectToWorldDir( v.tangent.xyz );
				half tangentSign = v.tangent.w * unity_WorldTransformParams.w;
				half3 worldBinormal = cross( worldNormal, worldTangent ) * tangentSign;
				o.tSpace0 = float4( worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x );
				o.tSpace1 = float4( worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y );
				o.tSpace2 = float4( worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z );
				o.customPack1.xy = customInputData.uv_texcoord;
				o.customPack1.xy = v.texcoord;
				o.customPack1.zw = customInputData.uv2_texcoord2;
				o.customPack1.zw = v.texcoord1;
				TRANSFER_SHADOW_CASTER_NORMALOFFSET( o )
				return o;
			}
			half4 frag( v2f IN
			#if !defined( CAN_SKIP_VPOS )
			, UNITY_VPOS_TYPE vpos : VPOS
			#endif
			) : SV_Target
			{
				UNITY_SETUP_INSTANCE_ID( IN );
				Input surfIN;
				UNITY_INITIALIZE_OUTPUT( Input, surfIN );
				surfIN.uv_texcoord = IN.customPack1.xy;
				surfIN.uv2_texcoord2 = IN.customPack1.zw;
				float3 worldPos = float3( IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w );
				half3 worldViewDir = normalize( UnityWorldSpaceViewDir( worldPos ) );
				surfIN.worldPos = worldPos;
				surfIN.worldNormal = float3( IN.tSpace0.z, IN.tSpace1.z, IN.tSpace2.z );
				surfIN.internalSurfaceTtoW0 = IN.tSpace0.xyz;
				surfIN.internalSurfaceTtoW1 = IN.tSpace1.xyz;
				surfIN.internalSurfaceTtoW2 = IN.tSpace2.xyz;
				SurfaceOutputCustomLightingCustom o;
				UNITY_INITIALIZE_OUTPUT( SurfaceOutputCustomLightingCustom, o )
				surf( surfIN, o );
				UnityGI gi;
				UNITY_INITIALIZE_OUTPUT( UnityGI, gi );
				o.Alpha = LightingStandardCustomLighting( o, worldViewDir, gi ).a;
				#if defined( CAN_SKIP_VPOS )
				float2 vpos = IN.pos;
				#endif
				SHADOW_CASTER_FRAGMENT( IN )
			}
			ENDCG

#LINE 498

		}
	}
	Fallback "Diffuse"
	CustomEditor "ASEMaterialInspector"
}
